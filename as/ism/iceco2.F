c*********************
#if defined CO2INTER
c*********************

c-----------------------------------------------------------------------

      subroutine doco2 (tempmon, precmon, h, maskwater, 
     *                  rco2inter, ecc, obl, prec, timeice, dtimeco2)

c     Reads Genesis ascii data files generated by debplotdriveice
c     (first call, into [to,ta,pr]drive arrays).
c     Does matrix method transfer to tog, tag, prg monthly mean arrays. 

c     Calls bucket twice to calculate (i) Antarctic CO2 weathering (ice
c     grid), and (ii) global non-Antarctic CO2 weathering (GCM grid).

      use comicephys
      use comicegrid

      dimension 
     *  tempmon(nx,ny,nmon),  precmon(nx,ny,nmon),
     *  h(nx,ny), maskwater(nx,ny)

      logical first
      save first
      data first /.true./

c     agcm surface forcing arrays (read from files by debplotdriveice):
c     to* = spectral topography (m)
c     pr* = precipitation (mm/day)
c     ta* = air temperature at lowest agcm layer (C)
      dimension
     * tog(nlong,nlatg,   1),  todrive(nlong,nlatg,   1,nmat), 
     * tag(nlong,nlatg,nmon),  tadrive(nlong,nlatg,nmon,nmat),
     * prg(nlong,nlatg,nmon),  prdrive(nlong,nlatg,nmon,nmat)
      save todrive, tadrive, prdrive

      character*200 cpath(nmat), cfile
      character*6 csuffant(nmat)
c     9x2 matrix:
      data csuffant / 
     *                '2noco', '2nome', '2nowa',
     *                '2meco', '2meme', '2mewa',
     *                '2fuco', '2fume', '2fuwa',
     *                '3noco', '3nome', '3nowa',
     *                '3meco', '3meme', '3mewa',
     *                '3fuco', '3fume', '3fuwa' 
     *             /

      dimension 
     *  maskg(nlong,nlatg),  hiceg(nlong,nlatg), topogg(nlong,nlatg),
     *  dareag(nlong,nlatg), alongd(nlong,nlatg), alatgd(nlong,nlatg)
      save maskg, hiceg, dareag, alongd, alatgd, firstg
      logical firstg
      data firstg /.true./

      dimension alatt31(48), wgaust31(48)
      data alatt31 /
     *  -1.5212131731, -1.4569823009, -1.3923721142, -1.3276762287,
     *  -1.2629478409, -1.1982037311, -1.1334508412, -1.0686925583,
     *  -1.0039307308, -0.9391664533, -0.8744004155, -0.8096330743,
     *  -0.7448647446, -0.6800956510, -0.6153259588, -0.5505557923,
     *  -0.4857852479, -0.4210144016, -0.3562433151, -0.2914720392,
     *  -0.2267006173, -0.1619290868, -0.0971574813, -0.0323858319,
     *   0.0323858319,  0.0971574813,  0.1619290868,  0.2267006173,
     *   0.2914720392,  0.3562433151,  0.4210144016,  0.4857852479,
     *   0.5505557923,  0.6153259588,  0.6800956510,  0.7448647446,
     *   0.8096330743,  0.8744004155,  0.9391664533,  1.0039307308,
     *   1.0686925583,  1.1334508412,  1.1982037311,  1.2629478409,
     *   1.3276762287,  1.3923721142,  1.4569823009,  1.5212131731
     *   /

      data wgaust31 /
     *   0.0031533461,  0.0073275539,  0.0114772346,  0.0155793157,
     *   0.0196161605,  0.0235707608,  0.0274265097,  0.0311672278,
     *   0.0347772226,  0.0382413511,  0.0415450829,  0.0446745609,
     *   0.0476166585,  0.0503590356,  0.0528901895,  0.0551995037,
     *   0.0572772921,  0.0591148397,  0.0607044392,  0.0620394232,
     *   0.0631141923,  0.0639242386,  0.0644661644,  0.0647376968,
     *   0.0647376968,  0.0644661644,  0.0639242386,  0.0631141923,
     *   0.0620394232,  0.0607044392,  0.0591148397,  0.0572772921,
     *   0.0551995037,  0.0528901895,  0.0503590356,  0.0476166585,
     *   0.0446745609,  0.0415450829,  0.0382413511,  0.0347772226,
     *   0.0311672278,  0.0274265097,  0.0235707608,  0.0196161605,
     *   0.0155793157,  0.0114772346,  0.0073275539,  0.0031533461
     *   /

c        Initialization section for gcm forcing fields

c####################
      if (first) then
c####################
c------------------------------------
#if defined SUN || defined IGUANA
c------------------------------------
        do n=1,nmat
          cpath(n) = '/iguana/s0/pollard/Ice3d/Driveice/Gcm/gen2/'
     *               // csuffant(n)(1:lenchr(csuffant(n))) // '/'
        enddo
c-------------------
#elif defined LION
c-------------------
        do n=1,nmat
          cpath(n) = '/home2/dxp21/Driveice/Gcm/gen2/'
     *               // csuffant(n)(1:lenchr(csuffant(n))) // '/'
        enddo
c-------------------
#elif defined NCOM
c-------------------
        do n=1,nmat
          cpath(n) = '/home/geosc/tbellato/Driveice/Gcm/gen2/'
     *               // csuffant(n)(1:lenchr(csuffant(n))) // '/'
        enddo
c-----
#endif
c-----

c          Set gcm axes (along,alatg in comicegrid)

        do i=1,nlong
c         cut at dateline: fields on gcm files have been shifted 180 deg
          along(i) = -pi + 2.*pi*(i-0.5)/nlong
        enddo
        do j=1,nlatg
          alatg(j) = alatt31(j)
        enddo

c          Open and read gcm forcing files into *drive arrays

        do m=1,nmat
          cfile = cpath(m)(1:lenchr(cpath(m)))//'data_icedrive_TO'
          call readdrive2 (iuclim, cfile, todrive(1,1,1,m), 'TO', 1)

          cfile = cpath(m)(1:lenchr(cpath(m)))//'data_icedrive_PR'
          call readdrive2 (iuclim, cfile, prdrive(1,1,1,m), 'PR', nmon)

          cfile = cpath(m)(1:lenchr(cpath(m)))//'data_icedrive_TA'
          call readdrive2 (iuclim, cfile, tadrive(1,1,1,m), 'TA', nmon)
        enddo

c          Transfer gcm topography todrive to tog, with matrix method

        call domatrix2 (tog, todrive, facice, facorb, facco2, 1,    1)

        first = .false.

c##########
      endif  ! end of initialization section
c##########

c        Compute matrix factors facice, facorb, facco2

      call fac_matrix2 (timeice, facice, facorb, facco2,
     *                 rco2inter, h, darea, nx,ny)

c        Transfer gcm tadrive to tag, prdrive to prg, with matrix method

      call domatrix2 (tag, tadrive, facice, facorb, facco2, nmon, 2)
      call domatrix2 (prg, prdrive, facice, facorb, facco2, nmon, 3)

c              Diagnostic checks

c     if (nstep.eq.1 .or. mod(nstep,nspy).eq.0) then
c       write (ioterm,'(/a,i4,a,f7.3)')'year=',iyear,
c    *                                '  day=',calday-1.
c       call gcheck2 ('TO', tog ,1., ioterm)
c       call gcheck2 ('PR', prg, 86400., ioterm)
c       call gcheck2 ('TA', tag, 1., ioterm)
c     endif

c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
c        Run soil bucket model + weathering, for Antarctic (ice grid) 
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

      weathering_antarctic=0

c     call bucket (tempmon, precmon, 
c    *             h, maskwater, darea, alond, alatd, 
c    *             rco2inter, ecc, obl, prec, timeice, dtimeco2,
c    *             nx, ny, nmon, 0,
c    *             weathering, weathering_antarctic)
     
      weathering_antarctic = weathering
     
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

c<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
c        Run soil bucket model + weathering, for globe except Antarctic
c        (gcm grid) 
c<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

c     if first call, set gcm grid axes, etc:
c~~~~~~~~~~~~~~~~~~~~~
      if (firstg) then
c~~~~~~~~~~~~~~~~~~~~~
        totglob = 4.*pi*radius**2
        do j=1,nlatg
          do i=1,nlong
            alongd(i,j) = along(i)*180./pi
            alatgd(i,j) = alatg(j)*180./pi
            dareag(i,j) = totglob * 0.5*wgaust31(j) / nlong
          enddo
        enddo

        totcheck = 0.
        do j=1,nlatg
          do i=1,nlong
            totcheck =  totcheck + dareag(i,j)
          enddo
        enddo
        totcheck2 = 0.
        do j=1,nlatg
          do i=1,nlong
            dareag(i,j) = dareag(i,j)*totglob/totcheck
            totcheck2 =  totcheck2 + dareag(i,j)
          enddo
        enddo

c       set ice sheet extent on gcm grid (zero outside Antarctica, 
c       ok to be zero everywhere here):   
        call zero (hiceg, nlong*nlatg)

c       deduce gcm land-ocean mask from topography file:
#if defined SUN || defined IGUANA
        cfile = '/iguana/s1/pollard/Datafiles/34ma/'
#elif defined LION
        cfile = '/home2/dxp21/Datafiles/34ma/'
#elif defined NCOM
        cfile ='/home/geosc/tbellato/Datafiles/34ma/'
#endif
        cfile = cfile(1:lenchr(cfile)) // 'data_35ma_med_top_T31'

        open (iuclim, file=cfile, form='formatted', status='old')
        call readdata_ice2 (iuclim, topogg, nlong,nlatg,
     *                     nlong,nlatg, 'TOPO    ',  2, 1)
        close (iuclim)
        do j=1,nlatg
          do i=1,nlong
            if (topogg(i,j).eq.0.) then
              maskg(i,j) = 1 
            else
              maskg(i,j) = 0 
            endif
          enddo
        enddo

c       diagnostic printouts:
c       do j=nlatg,1,-1
c         write (177,'(96i1)') (maskg(i,j),i=1,nlong)
c       enddo
c       write (177,'(i4, f8.2)') (j, alatgd(nlong/2,j), j=1,nlatg)
c       write (177,'(f12.6)') totcheck2/totglob 
c
c       do m=1,nmon
c         write (178,'(a,i4)') 'mon=',m
c         write (179,'(a,i4)') 'mon=',m
c         if (m.eq.1) write (180,'(a,i4)') 'mon=',m
c         do j=nlatg,1,-1
c           write (178,'(96i4)') (nint(tag(i,j,m)),i=1,nlong)
c           write (179,'(96i4)') (nint(10.*prg(i,j,m)),i=1,nlong)
c           if (m.eq.1) 
c             write(180,'(96i4)') (nint(0.1*tog(i,j,1)),i=1,nlong)
c         enddo
c       enddo
 
        firstg = .false.
c~~~~~~~~~~
      endif
c~~~~~~~~~~

c<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
c     call bucket (tag, prg, hiceg, maskg, dareag, alongd, alatgd, 
c    *             rco2inter, ecc, obl, prec, timeice, dtimeco2,
c    *             nlong, nlatg, nmon, 1, 
c    *             weathering, weathering_antarctic)
c<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

      return
      end

c----------------------------------------------------------------------

      subroutine readdrive2 (iu, cfile, fielddrive, ckey, nmonin)

c     Reads mid-month driving fields from a Genesis (debplotdriveice)
c     data input file (iu,cfile) into array fielddrive, for months
c     1 to nmonin. nmonin = nmon for all calls, except 1 for topog 
c     fields (ckey='TO'). Reads entire file into memory.

      use comicephys
      use comicegrid

      character*(*) cfile, ckey
      dimension fielddrive (nlong,nlatg,nmonin)

c        Open existing data input file

      open (iu, file=cfile, form='formatted', status='old')

c        Read scaling factor

      read (iu,'(7x,f12.5)') scale

c        Read monthly-mean global fields

      do 210 imon=1,nmonin
        call readdata_ice2 (iu, fielddrive(1,1,imon), nlong,nlatg,
     *                     nlong,nlatg, ckey,2, imon)
  210 continue

      close (iu)

c          Divide by scaling factor

      do imon=1,nmonin
        do jg=1,nlatg
          do ig=1,nlong
            fielddrive(ig,jg,imon) = fielddrive(ig,jg,imon) / scale
          enddo
        enddo
      enddo

      call checkfield2 (fielddrive, nmonin, ckey, -10000., 100000.)

      return
      end

c----------------------------------------------------------------------

      SUBROUTINE readdata_ice2 (IU, ARR, MLONA,MLATA, MLON,MLAT,
     *                         CKEY, ICODE, INUM)
C
C        Reads an agcm or lsx data input file, checking on label and
C        dimensions in header record. Data files are ascii, with 1
C        header record, 3 skip records (blank, longitude grid, blank),
C        and MLAT data records. Each data record contains a
C        latitude grid value, followed by MLON data values either
C        in A1 or F5.0 format (flagged by ICODE). The longitudes are
C        western hemisphere first, then eastern, ie, (I=MLON/2+1,MLON),
C        (I=1,MLON/2). The data records are in reverse latitude-grid 
C        order (J=MLAT,1,-1). Data values are returned in *real* array
C        ARR.
C
C        Permissible characters in A1 format are 0-9, blank(=0),
C        A-Z (=10-35), or a-z(=10-35).
C
C        If file has more than one field, each set of data records is
C        preceded by the same 4 records as above. Each group is
C        separated by an extra blank line, between the last data record
C        of the preceding field and the header record of the next field.
C        
C        IU    = unit number
C        ARR   = data array (returned)
C        MLONA = longitude dimension of ARR
C        MLATA = latitude  dimension of ARR
C        MLON  = longitude dimension of data
C        MLAT  = latitude  dimension of data
C        CKEY  = expected 8-byte label in word # 1, rec # 1
C        ICODE = 1 for A1 format, 2 for F5.0 format.
C        INUM  = field number for this file

      DIMENSION ARR(MLONA,MLATA)
      CHARACTER CKEY*(*)
      CHARACTER CRR(2160,1080)*1, CKEYZ*8, COMMENT*100
C
C        Initialize record number (just for error messages)
C
      IREC = (INUM-1)*(4+MLAT) + MAX(INUM-2,0)
C
C        If past first field, skip blank line separator
C
      
      IF (INUM.GT.1) THEN
        IREC = IREC + 1
        READ(IU, *, ERR=900, IOSTAT=IOS)
      ENDIF
C
C        Read header record
C
      IREC = IREC + 1
      READ(IU, 10, ERR=900, IOSTAT=IOS) CKEYZ, MLONZ, MLATZ, COMMENT
   10 FORMAT(A8,2I8,8X,A)

      IF (CKEYZ.NE.CKEY .OR. MLONZ.NE.MLON .OR. MLATZ.NE.MLAT) THEN
         WRITE(6,12) ckey,         COMMENT(1:LENCHR(COMMENT)),
     *                  CKEYZ,MLONZ,MLATZ, CKEY//'        ',MLON,MLAT
   12    FORMAT(/' *** Fatal Error.',
     *           ' Incorrect attributes for data file ',A
     *          /'     File comment                        = ',A,
     *          /'     File     label, longitude, latitude = ',A8, 2I6
     *          /'     Expected label, longitude, latitude = ',A8, 2I6/)
         stop
      ENDIF
C
C        Skip 3 records (blank, longitude grid, blank)
C
      IREC = IREC + 3
      READ(IU, 50, ERR=900, IOSTAT=IOS)
   50 FORMAT(//)
C
      IF (ICODE.EQ.1) THEN
C
C          Read "A1-format" data records
C
        DO 100 J=MLAT,1,-1
          IREC = IREC + 1
c         READ (IU,102,ERR=900,IOSTAT=IOS) (CRR(I,J),I=MLON/2+1,MLON),
c    *                                     (CRR(I,J),I=1,MLON/2)
c         Don't change from dateline to greenwich for ice grid
          READ (IU,102,ERR=900,IOSTAT=IOS) (CRR(I,J),I=1,MLON)
  102     FORMAT(5X,3X,2160A1)
          DO 104 I=1,MLON
            IC = ICHAR(CRR(I,J)(1:1))
            IF (IC.EQ.ICHAR(' ')) THEN
              ARR(I,J) = 0
            ELSE IF (IC.GE.ICHAR('0') .AND. IC.LE.ICHAR('9')) THEN
              ARR(I,J) = IC - ICHAR('0')
            ELSE IF (IC.GE.ICHAR('A') .AND. IC.LE.ICHAR('Z')) THEN
              ARR(I,J) = IC - ICHAR('A') + 10
            ELSE IF (IC.GE.ICHAR('a') .AND. IC.LE.ICHAR('z')) THEN
              ARR(I,J) = IC - ICHAR('a') + 10
            ELSE
              GOTO 910
            ENDIF
  104     CONTINUE
  100   CONTINUE
C
      ELSE
C
C          Read "F5.0-format" data records
C
        DO 150 J=MLAT,1,-1
          IREC = IREC + 1
c         READ (IU,152,ERR=900,IOSTAT=IOS) (ARR(I,J),I=MLON/2+1,MLON),
c    *                                     (ARR(I,J),I=1,MLON/2)
c         Don't change from dateline to greenwich for ice grid
          READ (IU,152,ERR=900,IOSTAT=IOS) (ARR(I,J),I=1,MLON)
  152     FORMAT(5X,3X,2160F5.0)
  150   CONTINUE
C
      ENDIF

      RETURN

C        Fatal errors
C
  900 WRITE(6,902) ckey,         COMMENT, IREC, IOS
  902 FORMAT(/' *** Error reading data file ',A
     *       /'     File comment = ',A
     *       /'     record number=',I6
     *       /'     Iostat code  =',I6/)
      stop
C
  910 WRITE(6,912) ckey,         COMMENT, IREC, I, J, CRR(I,J)
  912 FORMAT(/' *** Bad character in data file ',A
     *       /'     File comment    = ',A
     *       /'     record number   =',I6
     *       /'     longitude index =',I6
     *       /'     latitude  index =',I6
     *       /'     bad character   = ',A1/)
      stop
C
      END

c----------------------------------------------------------------------

      subroutine checkfield2 (fielddrive,nmonin,ckey,checkmin,checkmax)

c Checks extreme values in array fielddrive 

      use comicephys
      use comicegrid

      character*(*) ckey

      dimension fielddrive (nlong,nlatg,nmonin)

      zmin =  1.e20
      zmax = -1.e20
      zav  = 0.
      zava = 0.
      do imon=1,nmonin
        do jg=1,nlatg
          zwei = cos(alatg(jg))
          do ig=1,nlong
            zmin = min (zmin, fielddrive(ig,jg,imon))
            zmax = max (zmax, fielddrive(ig,jg,imon))
            zav  = zav  + fielddrive(ig,jg,imon)*zwei
            zava = zava +                        zwei
          enddo
        enddo
      enddo
      zav = zav/zava

      if (zmin.lt.checkmin .or. zmax.gt.checkmax) then
        write (ioterm,100) ckey, zav, zmin, zmax
      else
        write (ioterm,102) ckey, zav, zmin, zmax
      endif
  100 format('**OUT**  ', a8, '  av,min,max =',3e15.4)
  102 format('   (in)  ', a8, '  av,min,max =',3f10.3)

      return
      end

c-----------------------------------------------------------------------

      subroutine gcheck2 (ckeyin, field, factor, iu)

      use comicephys
      use comicegrid

c        Prints global mean of array field(nx,ny) (* factor)

      character*(*) ckeyin, ckey*8
      dimension field(nlong,nlatg)

      ckey = ckeyin

      gav   = 0.
      garea = 0.
      do 100 j=1,nlatg
        zwei = cos(alatg(j))*(pi/ny)*(2.*pi/nx)
        do 102 i=1,nlong
          gav   = gav   + zwei*field(i,j)*factor
          garea = garea + zwei
  102   continue
  100 continue
      gav = gav/garea

      write(iu,200) ckey, gav
  200 format('gcheck2: ',a,'   globav=',f14.6)

      return
      end

c-----------------------------------------------------------------------

      subroutine domatrix2 (arr,arrm, facice,facorb,facco2,nmonin,itype)

c       Does "matrix method" interpolation of a meteorological driving
c       field. 
c       Computes:
c         sigma[weimat(m)*arrm(..,..,m)]   for topog,temp.
c         sigma[weimat(m)*arrm(..,..,m)]   for precip.
c         where weimat(m) are matrix weights depending on facice,facorb,
c               facco2,and the corresp values of the nmat experiments.
c       All arguments supplied unless noted.
c         arr  = interpolated field (returned, dim: lon,lat,nmonin)
c         arrm = matrix of experiment fields (dim: lon,lat,nmonin,nmat)
c         facice = weighting factor for ice (computed in fac_matrix2)
c                  (0 to 1)
c         facorb = weighting factor for orbit (" " " " " " " " " " )
c         facco2 = weighting factor for co2   (" " " " " " " " " " )
c         itype  = 1 for topog  (additive), 
c                  2 for temp   (additive),
c                  3 for precip (additive (not ratio?)).

      use comicephys
      use comicegrid

      dimension
     *  arr(nlong,nlatg,nmonin), arrm(nlong,nlatg,nmonin,nmat)

      dimension expice(3)
      save expice
      data expice
c       from mask, plot.in.ant on pangea:
     *  /0.,  .528,    1./  ! area/max area in co,me,wa GCM expts

      dimension weiice(3), weiorb(3), weico2(2), weimat(nmat)

c     constrain weiice's to be <= 1:
      weiice(1) = min( 1., max (0.,
     *                 (expice(2)-facice)/(expice(2)-expice(1)) ))
      weiice(3) = min (1., max (0.,
     *                  (facice-expice(2))/(expice(3)-expice(2)) ))
      weiice(2) = 1. - (weiice(1)+weiice(3))         !weiice's sum to 1

c     no orbital signal, use "me" orbit
      weiorb(1) = 0.
      weiorb(2) = 1.
      weiorb(3) = 0.

      weico2(1) = facco2
      weico2(2) = 1. - facco2

c     nb: orb is "rows", ice is "columns" (see cpath() in climate_gcm)

      zw = 0.
      do k=1,2
        do j=1,3
          do i=1,3
            m = i + (j-1)*3 + (k-1)*9
            weimat(m) = weiorb(i)*weiice(j)*weico2(k)
            zw = zw + weimat(m)
          enddo
        enddo
      enddo
      if (abs(zw-1.).gt.1.e-6) then                  !weimat's sum to 1
        write (ioterm,'(a,e15.6)') '*** Error (domatrix2):zw.ne.1,= ',zw
        stop
      endif

      do imon=1,nmonin
        do j=1,nlatg
          do i=1,nlong
            arr(i,j,imon) = 0.
            do m=1,nmat
              arr(i,j,imon) = arr(i,j,imon) + weimat(m)*arrm(i,j,imon,m)
            enddo
c           precip:
            if (itype.eq.3) arr(i,j,imon) = max (arr(i,j,imon), 0.) 
          enddo
        enddo
      enddo

      return
      end

c-----------------------------------------------------------------------

      subroutine fac_matrix2 (time, facice, facorb, facco2,
     *                       rco2, h, darea, nx, ny)

c        Computes weights facice, facorb, facco2 for matrix method.
c
c        time = current time, -yr BP (eg, -21000) (supplied)
c        facice = ice extent interpolation matrix factor (0-1,returned)
c        facorb = orbit interpolation matrix factor (W/m2, returned)
c        facco2 = co2 interpolation matrix factor (returned)
c        h     = ice sheet thickness, m (supplied)
c        darea = ice grid box area, m**2 (supplied)
c        nx,ny = ice grid dimensions (supplied)

      dimension h(nx,ny), darea(nx,ny)

c        Compute facice, current ice-sheet surface area 
c        (albedo/topog feedbck)

      ztotari = 0.
      ztotice = 0.
      do j=1,ny
        do i=1,nx
          if (h(i,j).gt.0.) ztotari = ztotari + darea(i,j)
          ztotice = ztotice + h(i,j)*darea(i,j)
        enddo
      enddo
      ztotari = ztotari*1.e-6 ! m2 to km2
      ztotice = ztotice*1.e-9 ! m3 to km3
c     facice = min (1., (ztotari/13.e6))  ! 777
      facice = min (1., (ztotice/26.e6))  ! 777

      facorb = 0.5                 ! no orbital signal, use "me" orbit

c        Compute facco2 (radiative effect of co2 is logarithmic
c        wrt concentration):

      facco2 = (log(3.)-log(rco2)) / (log(3.)-log(2.))

c     write (6,'(a/i10, 3f8.3, i10, i10)') 
c    *  '      time  facice  facorb  facco2    totari    totice',
c    *  nint(time), facice, facorb, facco2, nint(ztotari), nint(ztotice)

      return
      end

c-----------------------------------------------------------------------

c****
#else
c****

      subroutine doco2 ()
      return
      end

c*****
#endif
c*****
