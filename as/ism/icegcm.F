c**********************
#if defined GCMMATRIX
c**********************

c-----------------------------------------------------------------------

      subroutine climate_gcm (budgsnow, budgrain, budgevap, budgmelt,
     *                        tsurf, tsurfi,
     *                        h, hs, maskwater,
     *                        sealev, dtantann, dtantjan, dtseas,
     *                        rco2, ecc, obl, prec,
     *                        facice, facorb, facco2,
#if defined CO2INTER
     *                        tempmon, precmon,
#endif
     *                        timeice, weirun, ifrest, first)

c     Calls snow/ice "model" (surfice_pdd) years to get annual ice mass 
c     balance forcing, using surface forcing fields from gcm data files.
c     Reads Genesis ascii data files generated by debplotdriveice.

c     Gcm data files are read just once at start into large arrays 
c     *drive(..,..,nmon,nmat) by readdrive, and subsequent 
c     time-interpolation is done in intdrive.

      use comicephys
      use comicegrid

      dimension 
     *  budgsnow(nx,ny), budgrain(nx,ny),
     *  budgevap(nx,ny), budgmelt(nx,ny),
     *  tsurf(nx,ny),    tsurfi(nx,ny),
     *  h(nx,ny),        hs(nx,ny),      maskwater(nx,ny)
#if defined CO2INTER
     * ,tempmon(nx,ny,12),   precmon(nx,ny,12)
#endif
      logical first

c     local 2-D ice-grid arrays:
      dimension
     *  pmemr(nx,ny),    arain(nx,ny),   asnow(nx,ny),
     *  amelt(nx,ny),    ablat(nx,ny),   apdd(nx,ny),
     *  hsnow(nx,ny),    iftodo(nx,ny),
     *  indl(nx,ny),     weil(nx,ny),
     *  indb(nx,ny),     weib(nx,ny),
     *  hsprevcalc(nx,ny)

c     save since may only be set for a subset of points 
c     (whose elev changed enough since last call)
      save pmemr, arain, asnow, amelt, ablat, apdd, hsnow

      save indl, weil, indb, weib, hsprevcalc, timeiceprevall
      data timeiceprevall /0./       ! just to avoid indef below

c     local 1-D ice-strip arrays:
      dimension 
     *  toa(nvec), 
     *  pra(nvec),    raa(nvec),    sna(nvec),
     *  ta(nvec),
     *  tice(nvec),   tsno(nvec),
     *  dmelta(nvec), pdd(nvec),
c       annual accumulators:
     *  araina(nvec), asnowa(nvec), amelta(nvec),
     *  taira(nvec),  ticea(nvec),  pdda(nvec),
c       annual quantities (and hsnowa multiyear):
     *  ablata(nvec), pmemra(nvec), hsnowa(nvec),
     *  iland(nvec,2)

c     agcm surface forcing arrays (read from files by debplotdriveice):
c     to* = spectral topography (m)
c     pr* = precipitation (mm/day)
c     ta* = air temperature at lowest agcm layer (C)
      dimension
     * tog (nlong,nlatg,   1),    todrive(nlong,nlatg,   1,nmat),
     * tage(nlong,nlatg,nmon),    tadrive(nlong,nlatg,nmon,nmat),
     * prge(nlong,nlatg,nmon),    prdrive(nlong,nlatg,nmon,nmat),
     * tag(nlong,nlatg), 
     * prg(nlong,nlatg)

      save tog,     tage,    prge, 
     *     todrive, tadrive, prdrive

      character*200 cpath(nmat), cfile
#if defined EISANTA
      character*6 csuffant(nmat)
      data csuffant / 
c 9x2 matrix:
     *                '2noco', '2nome', '2nowa',
     *                '2meco', '2meme', '2mewa',
     *                '2fuco', '2fume', '2fuwa',
     *                '3noco', '3nome', '3nowa',
     *                '3meco', '3meme', '3mewa',
     *                '3fuco', '3fume', '3fuwa' 
c Or mis31 gcm (1 = 1.070 Ma, 2 = 1.082 Ma, see domatrix):
c    *                'Mis31g' , 'Mis31f'
     *             /
#endif

      dimension alatt31(48)
      data alatt31 /
     *  -1.5212131731, -1.4569823009, -1.3923721142, -1.3276762287,
     *  -1.2629478409, -1.1982037311, -1.1334508412, -1.0686925583,
     *  -1.0039307308, -0.9391664533, -0.8744004155, -0.8096330743,
     *  -0.7448647446, -0.6800956510, -0.6153259588, -0.5505557923,
     *  -0.4857852479, -0.4210144016, -0.3562433151, -0.2914720392,
     *  -0.2267006173, -0.1619290868, -0.0971574813, -0.0323858319,
     *   0.0323858319,  0.0971574813,  0.1619290868,  0.2267006173,
     *   0.2914720392,  0.3562433151,  0.4210144016,  0.4857852479,
     *   0.5505557923,  0.6153259588,  0.6800956510,  0.7448647446,
     *   0.8096330743,  0.8744004155,  0.9391664533,  1.0039307308,
     *   1.0686925583,  1.1334508412,  1.1982037311,  1.2629478409,
     *   1.3276762287,  1.3923721142,  1.4569823009,  1.5212131731
     *   /

      call zero (budgsnow, nx*ny)
      call zero (budgrain, nx*ny)
      call zero (budgevap, nx*ny)
      call zero (budgmelt, nx*ny)
      
      dtimed = 5.*86400.   ! for degree day method, several-day timestep
      dtforc = 20.*86400. 

      nyear  = 2     ! more than 1 year to allow for spinup due to hsnow
 
      nspy   = max (1, nint((86400.*365  )/dtimed))
      nspf   = max (1, nint((dtforc      )/dtimed))

c        Initialization section for gcm forcing fields

c####################
      if (first) then
c####################
c------------------------------------
#if defined SUN || defined IGUANA
c------------------------------------
#if defined EISANTA
        do n=1,nmat
          cpath(n) = '/iguana/s0/pollard/Ice3d/Driveice/Gcm/gen2/'
     *               // csuffant(n)(1:lenchr(csuffant(n))) // '/'
        enddo
#elif defined NHA
        do n=1,nmat
          cpath(n) = '/iguana/s0/pollard/Ice3d/Driveice/Gcm/gen2/' 
     *               // 'Ctl/'
        enddo
#endif
c-------------------
#elif defined LION
c-------------------
#if defined EISANTA
        do n=1,nmat
          cpath(n) = '/home2/dxp21/Driveice/Gcm/gen2/'
     *               // csuffant(n)(1:lenchr(csuffant(n))) // '/'
        enddo
#elif defined NHA
        do n=1,nmat
          cpath(n) = '/home2/dxp21/Driveice/Gcm/gen2/' 
     *               // 'Ctl/'
        enddo
#endif
c---------------------
#elif defined CONDOR
c---------------------
#if defined EISANTA
        do n=1,nmat
          cpath(n) = '/condor/data2/pollard/Ice3d/Driveice/Gcm/gen2/'
     *               // csuffant(n)(1:lenchr(csuffant(n))) // '/'
        enddo
#elif defined NHA
        do n=1,nmat
          cpath(n) = '/condor/data2/pollard/Ice3d/Driveice/Gcm/gen2/'
     *               // 'Ctl/'
        enddo
#elif defined CARB
        do n=1,nmat
          cpath(n) = '/condor/data2/pollard/Ice3d/Driveice/Gcm/gen2/'
     *               // '280ma/'
        enddo
#endif
c------------------
#elif defined NCOM
c------------------
        do n=1,nmat
          cpath(n) = '/home/geosc/tbellato/Driveice/Gcm/gen2/'
     *               // csuffant(n)(1:lenchr(csuffant(n))) // '/'
        enddo
c-----
#endif
c-----

c          Set gcm axes (along,alatg in comicegrid)

        do i=1,nlong
c         cut at dateline: fields on gcm files have been shifted 180 deg
          along(i) = -pi + 2.*pi*(i-0.5)/nlong
        enddo
        do j=1,nlatg
          alatg(j) = alatt31(j)
        enddo

c          Open and read gcm forcing files into *drive arrays

        do m=1,nmat
          cfile = cpath(m)(1:lenchr(cpath(m)))//'data_icedrive_TO'
          call readdrive (iuto, cfile, todrive(1,1,1,m), 'TO', 1)

          cfile = cpath(m)(1:lenchr(cpath(m)))//'data_icedrive_PR'
          call readdrive (iupr, cfile, prdrive(1,1,1,m), 'PR', nmon)

          cfile = cpath(m)(1:lenchr(cpath(m)))//'data_icedrive_TA'
          call readdrive (iuta, cfile, tadrive(1,1,1,m), 'TA', nmon)
        enddo

c          Set indices for bilinear interp (ind*,wei* local,saved)

        call setinterp (along, alatg, nlong, nlatg, 
     *                  alond, alatd, nx, ny, radius,
     *                  indl, weil, indb, weib)

c##########
      endif  ! end of initialization section
c##########

c        Compute matrix factors facice, facorb, facco2

      call fac_matrix (timeice, weirun, rco2, ecc, obl, prec,
     *                 facice, facorb, facco2,
     *                 h, darea, nx, ny)

c     facice = 0.                     ! mis31 gcm
c     facorb = dtantjan/0.1 + 529.85  ! mis31 gcm (Jan insol, 80S, W/m2)
c     facco2 = 0.                     ! mis31 gcm

c        Transfer gcm [to,ta,pr]drive to [to,ta,pr]ge with matrix method

      call domatrix (tog,  todrive, facice, facorb, facco2, 1,    1)
      call domatrix (tage, tadrive, facice, facorb, facco2, nmon, 2)
      call domatrix (prge, prdrive, facice, facorb, facco2, nmon, 3)

#if defined CO2INTER
c        Set monthly mean T,P on ice grid (returned for weathering).
c        Similar to annual cycle code below, including elev correction.

      do j=1,ny
        do i=1,nx
c         indices and weights into agcm-grid arrays (setinterp):
          il = indl(i,j)
          ir = mod (il,nlong) + 1
          jb = indb(i,j)
          jt = min (jb+1, nlatg)
          wlb =     weil(i,j) *    weib(i,j)
          wrb = (1.-weil(i,j))*    weib(i,j)
          wlt =     weil(i,j) *(1.-weib(i,j))
          wrt = (1.-weil(i,j))*(1.-weib(i,j))
          ztoa = tog(il,jb,1)*wlb + tog(ir,jb,1)*wrb
     *         + tog(il,jt,1)*wlt + tog(ir,jt,1)*wrt
          zdelev = hs(i,j) - ztoa
          do im=1,nmon
            precmon(i,j,im) = prge(il,jb,im)*wlb + prge(ir,jb,im)*wrb
     *                      + prge(il,jt,im)*wlt + prge(ir,jt,im)*wrt
            tempmon(i,j,im) = tage(il,jb,im)*wlb + tage(ir,jb,im)*wrb
     *                      + tage(il,jt,im)*wlt + tage(ir,jt,im)*wrt
c           apply elevation correction to sfc air temperature ta:
            tempmon(i,j,im) = tempmon(i,j,im) - rlapse*zdelev
          enddo
        enddo
      enddo
#endif

c        Set points to be calculated this call (iftodo, npoi, iland)

c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if (first .or. nint(abs(timeice-timeiceprevall)).ge.1000) then
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

c       if first call this run or every 1000 years, do entire domain:
        npoi = 0
        do j=1,ny
          do i=1,nx
            iftodo(i,j) = 1
            npoi = npoi + 1
            iland(npoi,1) = i
            iland(npoi,2) = j
          enddo
        enddo
        call scopy (nx*ny, hs, 1, hsprevcalc, 1)
        timeiceprevall = timeice

c~~~~~~~~~
      else
c~~~~~~~~~

c       do points whose sfc elev has changed > 50 m since last calc:
        npoi = 0
        do j=1,ny
          do i=1,nx
            if (abs(hs(i,j)-hsprevcalc(i,j)).gt.50.) then
              iftodo(i,j) = 1
              npoi = npoi + 1
              iland(npoi,1) = i
              iland(npoi,2) = j
              hsprevcalc(i,j) = hs(i,j)
            else
              iftodo(i,j) = 0
            endif
          enddo
        enddo
        if (npoi.eq.0) return

c~~~~~~~~~~
      endif
c~~~~~~~~~~

c     write (195,'(a,i10,a,i8)')
c    *  'climate_gcm:  timeice=',nint(timeice),'  npoi=',npoi
c     call flush(195)

c        Zero initial snow thickness (carried over from year to year)

      do ip=1,npoi
        hsnowa(ip) = 0.
      enddo

c        Loop over years

c=====================
      do iyear=1,nyear
c=====================

c          Zero annual accumulators

        do ip=1,npoi
          araina(ip) = 0.
          asnowa(ip) = 0.
          amelta(ip) = 0.
          taira (ip) = 0.
          ticea (ip) = 0.
          pdda  (ip) = 0.
        enddo

c          Loop over timesteps through one year

c======================
        do nstep=1,nspy
c======================

          isecyr = nint((nstep-0.5)*dtimed)           ! for degree-days
          isecdy = mod(isecyr,86400)
          calday = 1. + isecyr/86400.

c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          if (nstep.eq.1 .or. mod(nstep,nspf).eq.0) then
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

c              Interpolate current surface forcing 

            call intdrive (calday, tag, tage)
            call intdrive (calday, prg, prge)

c              Change various units to MKS

            do jg=1,nlatg
              do ig=1,nlong 
                prg(ig,jg) = prg(ig,jg)/86400.      ! mm/day to kg/m2/s
                tag(ig,jg) = tag(ig,jg) + tmelt     ! deg C to K
              enddo
            enddo

c              Diagnostic checks

c           if (nstep.eq.1 .or. mod(nstep,nspy).eq.0) then
c             write (ioterm,'(/a,i4,a,f7.3)')'year=',iyear,
c    *                                      '  day=',calday-1.
c             call gcheck ('TO', tog , 1., ioterm)
c             call gcheck ('PR', prg,  86400., ioterm)
c             call gcheck ('TA', tag,  1., ioterm)
c           endif

c              Interpolate meteorological forcing to ice-grid arrays

c-----------------------
            do ip=1,npoi
c-----------------------

c                Indices into ice-grid arrays

              i = iland(ip,1)
              j = iland(ip,2)

c                Indices and weights into agcm-grid arrays (setinterp)

              il = indl(i,j)
              ir = mod (il,nlong) + 1
              jb = indb(i,j)
              jt = min (jb+1, nlatg)
              wlb =     weil(i,j) *    weib(i,j)
              wrb = (1.-weil(i,j))*    weib(i,j)
              wlt =     weil(i,j) *(1.-weib(i,j))
              wrt = (1.-weil(i,j))*(1.-weib(i,j))
  
c                Interpolate agcm forcing fields to ice-grid point

              toa(ip) =   tog(il,jb,1)*wlb + tog(ir,jb,1)*wrb
     *                  + tog(il,jt,1)*wlt + tog(ir,jt,1)*wrt
  
              pra(ip) =   prg(il,jb)*wlb + prg(ir,jb)*wrb
     *                  + prg(il,jt)*wlt + prg(ir,jt)*wrt

              ta(ip)  =   tag(il,jb)*wlb + tag(ir,jb)*wrb
     *                  + tag(il,jt)*wlt + tag(ir,jt)*wrt

c             uniform temperature perturbation:
c             ta(ip) = ta(ip) - 5.              ! 777
c             ta(ip) = ta(ip) + 2. - 4.*weirun  ! 777

c                Apply elevation corrections to sfc air temperature ta,
c                and set rainfall vs snowfall

              zdelev = hs(i,j) - toa(ip)

              zt1 = ta(ip)
              zt2 = ta(ip) - rlapse*zdelev
              ta(ip) = zt2

              zpr = pra(ip)
              if (ta(ip).gt.tmelt) then
                raa(ip) = zpr
                sna(ip) = 0.
              else
                raa(ip) = 0.
                sna(ip) = zpr 
              endif

c----------------
            enddo
c----------------

c>>>>>>>>>>>>>>
          endif
c>>>>>>>>>>>>>>

          call surfice_pdd
     *      ( dtimed,
     *        ta,      raa,    sna,
     *        dmelta,  hsnowa, 
     *        tice,    tsno,   pdd, 
     *        npoi)

c            Calculate diagnostic min/max surface temperatures
c            and test for blowup

          ztmin =  1.e20
          ztmax = -1.e20
          do ip=1,npoi
            if (tice(ip).lt.ztmin .or. tsno(ip).lt.ztmin) then
              ztmin = min (tice(ip), tsno(ip))
              ipmin = ip
            endif
            if (tice(ip).gt.ztmax .or. tsno(ip).gt.ztmax) then
              ztmax = max (tice(ip), tsno(ip))
              ipmax = ip
            endif
          enddo

          if (ztmin.lt.tmelt-120.) then
             imin = iland(ipmin,1)
             jmin = iland(ipmin,2)
             write (ioterm,273) iyear, nstep, isecyr/86400.,
     *         'tmin',ztmin-tmelt, 
     *         imin, jmin, alond(imin,jmin), alatd(imin,jmin)
  273        format('*** Warning: Extreme surface temperature(s)',
     *              ' at iyear=',i3,'   nstep=',i6,'   day=',f8.2
     *             /'  ',a,'=',f10.2,'  at i,j=',2i4,'  lon,lat=',2f8.2)
c            call flush(ioterm)    ! doesn't work on linux/iguana
          endif
          if (ztmax.gt.tmelt+90.) then
             imax = iland(ipmax,1)
             jmax = iland(ipmax,2)
             write (ioterm,273) iyear, nstep, isecyr/86400.,
     *         'max', ztmax-tmelt, 
     *         imax, jmax, alond(imax,jmax), alatd(imax,jmax)
c            call flush(ioterm)    ! doesn't work on linux/iguana
          endif

c            Increment annual snowfall, rainfall, melt (kg/m2/s)

          do ip=1,npoi
            araina(ip) = araina(ip) + dtimed*raa(ip)
            asnowa(ip) = asnowa(ip) + dtimed*sna(ip)
            amelta(ip) = amelta(ip) + dtimed*dmelta(ip)
            taira(ip)  = taira(ip)  + ta(ip)/nspy
            ticea(ip)  = ticea(ip)  + tice(ip)/nspy
            pdda(ip)   = pdda(ip)   + pdd(ip)
          enddo

c============
        enddo ! timestep loop
c============

c==========
      enddo ! year loop
c==========

c        Calculate annual budgets for last year, with correction for
c        refreezing. Assumes rain passes through snow with no
c        interaction.

      do ip=1,npoi
        i = iland(ip,1)
        j = iland(ip,2)

c          (1) No runoff if melt/snow < 0.95
c          (2) Fraction runs off if 0.95 < melt/snow < 1.05
c          (3) All runs off if 1.05 < melt/snow, or h=0 (no icesheet)

c            For degree-days model

c       ratsno = 2.7
c       ratice = 7.2
        ratsno = 3.5
        ratice = 7.0

        zpdd = pdda(ip)

        rsw = 0.25/1.0                                      ! rhos/rhow

c       melt 1.-rsw fraction of snow that will saturate snowpack:
        zsuper = min (asnowa(ip)*(1.-rsw), ratsno*zpdd)
        zpdd = zpdd - zsuper/ratsno
        zmelt = zsuper + ratice*zpdd

c       melt embedded snow in the saturated snowpack:
        zrunsno = min (asnowa(ip), (ratice/rsw)*zpdd)
        zpdd = zpdd - zrunsno/(ratice/rsw)

c       melt ice below snow:
        zrunice = ratice*zpdd

        ablata(ip) = zrunsno + zrunice                     ! passed back
        amelta(ip) = zmelt                                 ! diagnostic
        pmemra(ip) = asnowa(ip) - ablata(ip)               ! diagnostic

      enddo

c        Save budget quantities in full ice-grid arrays
c        (so can be displayed by printmap...otherwise could
c        do final calc of budg[snow,rain,ablat] below over 1:npoi,
c        and avoid 2-D arrays for arain, etc)

      do ip = 1,npoi
        i = iland(ip,1)
        j = iland(ip,2)
        arain(i,j) = araina(ip)
        asnow(i,j) = asnowa(ip)
        amelt(i,j) = amelta(ip)
        ablat(i,j) = ablata(ip)
        pmemr(i,j) = pmemra(ip)
        apdd(i,j)  = pdda(ip)
        hsnow(i,j) = hsnowa(ip)
c       returned to icectl:
        tsurf(i,j) = taira(ip)
        tsurfi(i,j)= ticea(ip)
      enddo

c        Transfer to budg* for ice model, 
c        converting flux units from kg/m2/yr to m/yr 
          
      do j=1,ny
        do i=1,nx
          budgsnow(i,j) = asnow(i,j)*.001             ! kg/m2/yr to m/yr
          budgrain(i,j) = arain(i,j)*.001             ! kg/m2/yr to m/yr
          budgmelt(i,j) = ablat(i,j)*.001             ! kg/m2/yr to m/yr
          budgevap(i,j) = 0.

c         ensure zero or slightly negative budget over open ocean:
          if (maskwater(i,j).eq.1) then
            zf = max(0., min (1.,  (h(i,j)-2.5)/2.5))              ! 777
            budgsnow(i,j) = zf * budgsnow(i,j)  + (1.-zf)*(0   )   ! 777
            budgrain(i,j) = zf * budgrain(i,j)  + (1.-zf)*(0.  )   ! 777
            budgevap(i,j) = zf * budgevap (i,j) + (1.-zf)*(0.  )   ! 777
            budgmelt(i,j) = zf * budgmelt(i,j)  + (1.-zf)*(0.02)   ! 777
          endif
        enddo
      enddo

c        Print out maps, if not a restart. 
c        Ok first call since whole domain has been calculated

      if (first .and. ifrest.ne.1) then
        write (iuout2d, '(/"*** METEO FIELDS (FIRST CALL) ***"/)') 
        call printmap (timeice, pmemr,'pmemr, mm/yr', 50., h, iuout2d,0)
        call printmap (timeice, arain,'arain, mm/yr', 50., h, iuout2d,0)
        call printmap (timeice, asnow,'asnow, mm/yr', 50., h, iuout2d,0)
        call printmap (timeice, amelt,'amelt, mm/yr', 50., h, iuout2d,0)
        call printmap (timeice, ablat,'ablat, mm/yr', 50., h, iuout2d,0)
        call printmap (timeice, apdd, 'apdd,  C*day', 50., h, iuout2d,0)
        call printmap (timeice, hsnow,'hsnow, m',      .1, h, iuout2d,0)
        write (iuout2d,'(/"*** END OF METEO FIELDS (FIRST CALL) ***"/)')
        call flush(iuout)
      endif

      return
      end

c----------------------------------------------------------------------

      subroutine readdrive (iu, cfile, fielddrive, ckey, nmonin)

c     Reads mid-month driving fields from a Genesis (debplotdriveice)
c     data input file (iu,cfile) into array fielddrive, for months
c     1 to nmonin. nmonin = nmon for all calls, except 1 for topog 
c     fields (ckey='TO'). Reads entire file into memory.

      use comicephys
      use comicegrid

      character*(*) cfile, ckey
      dimension fielddrive (nlong,nlatg,nmonin)

c        Open existing data input file

      open (iu, file=cfile, form='formatted', status='old')

c        Read scaling factor

      read (iu,'(7x,f12.5)') scale

c        Read monthly-mean global fields

      do 210 imon=1,nmonin
        call readdata_ice (iu, fielddrive(1,1,imon), nlong,nlatg,
     *                     nlong,nlatg, ckey,2, imon)
  210 continue

      close (iu)

c          Divide by scaling factor

      do imon=1,nmonin
        do jg=1,nlatg
          do ig=1,nlong
            fielddrive(ig,jg,imon) = fielddrive(ig,jg,imon) / scale
          enddo
        enddo
      enddo

      call checkfield (fielddrive, nmonin, ckey, -10000., 100000.)

      return
      end

c----------------------------------------------------------------------

      SUBROUTINE READDATA_ICE (IU, ARR, MLONA,MLATA, MLON,MLAT,
     *                         CKEY, ICODE, INUM)
C
C        Reads an agcm or lsx data input file, checking on label and
C        dimensions in header record. Data files are ascii, with 1
C        header record, 3 skip records (blank, longitude grid, blank),
C        and MLAT data records. Each data record contains a
C        latitude grid value, followed by MLON data values either
C        in A1 or F5.0 format (flagged by ICODE). The longitudes are
C        western hemisphere first, then eastern, ie, (I=MLON/2+1,MLON),
C        (I=1,MLON/2). The data records are in reverse latitude-grid 
C        order (J=MLAT,1,-1). Data values are returned in *real* array
C        ARR.
C
C        Permissible characters in A1 format are 0-9, blank(=0),
C        A-Z (=10-35), or a-z(=10-35).
C
C        If file has more than one field, each set of data records is
C        preceded by the same 4 records as above. Each group is
C        separated by an extra blank line, between the last data record
C        of the preceding field and the header record of the next field.
C        
C        IU    = unit number
C        ARR   = data array (returned)
C        MLONA = longitude dimension of ARR
C        MLATA = latitude  dimension of ARR
C        MLON  = longitude dimension of data
C        MLAT  = latitude  dimension of data
C        CKEY  = expected 8-byte label in word # 1, rec # 1
C        ICODE = 1 for A1 format, 2 for F5.0 format.
C        INUM  = field number for this file

      DIMENSION ARR(MLONA,MLATA)
      CHARACTER CKEY*(*)
      CHARACTER CRR(2160,1080)*1, CKEYZ*8, COMMENT*100
C
C        Initialize record number (just for error messages)
C
      IREC = (INUM-1)*(4+MLAT) + MAX(INUM-2,0)
C
C        If past first field, skip blank line separator
C
      
      IF (INUM.GT.1) THEN
        IREC = IREC + 1
        READ(IU, *, ERR=900, IOSTAT=IOS)
      ENDIF
C
C        Read header record
C
      IREC = IREC + 1
      READ(IU, 10, ERR=900, IOSTAT=IOS) CKEYZ, MLONZ, MLATZ, COMMENT
   10 FORMAT(A8,2I8,8X,A)

      IF (CKEYZ.NE.CKEY .OR. MLONZ.NE.MLON .OR. MLATZ.NE.MLAT) THEN
         WRITE(6,12) ckey,         COMMENT(1:LENCHR(COMMENT)),
     *                  CKEYZ,MLONZ,MLATZ, CKEY//'        ',MLON,MLAT
   12    FORMAT(/' *** Fatal Error.',
     *           ' Incorrect attributes for data file ',A
     *          /'     File comment                        = ',A,
     *          /'     File     label, longitude, latitude = ',A8, 2I6
     *          /'     Expected label, longitude, latitude = ',A8, 2I6/)
         stop
      ENDIF
C
C        Skip 3 records (blank, longitude grid, blank)
C
      IREC = IREC + 3
      READ(IU, 50, ERR=900, IOSTAT=IOS)
   50 FORMAT(//)
C
      IF (ICODE.EQ.1) THEN
C
C          Read "A1-format" data records
C
        DO 100 J=MLAT,1,-1
          IREC = IREC + 1
c         READ (IU,102,ERR=900,IOSTAT=IOS) (CRR(I,J),I=MLON/2+1,MLON),
c    *                                     (CRR(I,J),I=1,MLON/2)
c         Don't change from dateline to greenwich for ice grid
          READ (IU,102,ERR=900,IOSTAT=IOS) (CRR(I,J),I=1,MLON)
  102     FORMAT(5X,3X,2160A1)
          DO 104 I=1,MLON
            IC = ICHAR(CRR(I,J)(1:1))
            IF (IC.EQ.ICHAR(' ')) THEN
              ARR(I,J) = 0
            ELSE IF (IC.GE.ICHAR('0') .AND. IC.LE.ICHAR('9')) THEN
              ARR(I,J) = IC - ICHAR('0')
            ELSE IF (IC.GE.ICHAR('A') .AND. IC.LE.ICHAR('Z')) THEN
              ARR(I,J) = IC - ICHAR('A') + 10
            ELSE IF (IC.GE.ICHAR('a') .AND. IC.LE.ICHAR('z')) THEN
              ARR(I,J) = IC - ICHAR('a') + 10
            ELSE
              GOTO 910
            ENDIF
  104     CONTINUE
  100   CONTINUE
C
      ELSE
C
C          Read "F5.0-format" data records
C
        DO 150 J=MLAT,1,-1
          IREC = IREC + 1
c         READ (IU,152,ERR=900,IOSTAT=IOS) (ARR(I,J),I=MLON/2+1,MLON),
c    *                                     (ARR(I,J),I=1,MLON/2)
c         Don't change from dateline to greenwich for ice grid
          READ (IU,152,ERR=900,IOSTAT=IOS) (ARR(I,J),I=1,MLON)
  152     FORMAT(5X,3X,2160F5.0)
  150   CONTINUE
C
      ENDIF

      RETURN

C        Fatal errors
C
  900 WRITE(6,902) ckey,         COMMENT, IREC, IOS
  902 FORMAT(/' *** Error reading data file ',A
     *       /'     File comment = ',A
     *       /'     record number=',I6
     *       /'     Iostat code  =',I6/)
      stop
C
  910 WRITE(6,912) ckey,         COMMENT, IREC, I, J, CRR(I,J)
  912 FORMAT(/' *** Bad character in data file ',A
     *       /'     File comment    = ',A
     *       /'     record number   =',I6
     *       /'     longitude index =',I6
     *       /'     latitude  index =',I6
     *       /'     bad character   = ',A1/)
      stop
C
      END

c----------------------------------------------------------------------

      subroutine checkfield (fielddrive,nmonin,ckey,checkmin,checkmax)

c Checks extreme values in array fielddrive 

      use comicephys
      use comicegrid

      character*(*) ckey

      dimension fielddrive (nlong,nlatg,nmonin)

      zmin =  1.e20
      zmax = -1.e20
      zav  = 0.
      zava = 0.
      do imon=1,nmonin
        do jg=1,nlatg
          zwei = cos(alatg(jg))
          do ig=1,nlong
            zmin = min (zmin, fielddrive(ig,jg,imon))
            zmax = max (zmax, fielddrive(ig,jg,imon))
            zav  = zav  + fielddrive(ig,jg,imon)*zwei
            zava = zava +                        zwei
          enddo
        enddo
      enddo
      zav = zav/zava

      if (zmin.lt.checkmin .or. zmax.gt.checkmax) then
        write (ioterm,100) ckey, zav, zmin, zmax
      else
        write (ioterm,102) ckey, zav, zmin, zmax
      endif
  100 format('**OUT**  ', a8, '  av,min,max =',3e15.4)
  102 format('   (in)  ', a8, '  av,min,max =',3f10.3)

      return
      end

c----------------------------------------------------------------------

      subroutine intdrive (calday, field, fieldmon)

c    Lineary interpolates fieldmon(..,..,nmon) in time between the
c    midmonth points to current calday, and sets current array field.

c calday    = day number within current year (1. to 366.) (supplied)
c field     = 2D agcm current-time array (returned)
c fieldmon  = 2D agcm field for all mid months (supplied)

      use comicephys
      use comicegrid

      dimension field(nlong,nlatg), fieldmon(nlong,nlatg,nmon)

      dimension iday(0:nmon+1)
      data iday / -15.,  16.,  45.,  75., 105., 136., 166.,
     *                  197., 228., 258., 289., 319., 350.,381. /

c        Find interpolation indices for iday  (nb: calday runs from
c        1. to 366. from 00:00 GMT Jan 1st to 24:00 GMT Dec 31st)

      do im=1,nmon+1
        if (calday.le.iday(im)) then
          im1 = im-1
          im2 = im
          wm1 = (iday(im2)-calday) / (iday(im2)-iday(im1))
          if (im1.eq.0) im1 = nmon
          if (im2.eq.nmon+1) im2 = 1
          goto 102
        endif
      enddo
  102 continue

c        Interpolate to current time

      do jg=1,nlatg
        do ig=1,nlong
          field(ig,jg) = (      wm1 *fieldmon(ig,jg,im1)
     *                    + (1.-wm1)*fieldmon(ig,jg,im2) )
        enddo
      enddo

      return
      end

c-----------------------------------------------------------------------

      subroutine gcheck (ckeyin, field, factor, iu)

      use comicephys
      use comicegrid

c        Prints global mean of array field(nx,ny) (* factor)

      character*(*) ckeyin, ckey*8
      dimension field(nlong,nlatg)

      ckey = ckeyin

      gav   = 0.
      garea = 0.
      do 100 j=1,nlatg
        zwei = cos(alatg(j))*(pi/ny)*(2.*pi/nx)
        do 102 i=1,nlong
          gav   = gav   + zwei*field(i,j)*factor
          garea = garea + zwei
  102   continue
  100 continue
      gav = gav/garea

      write(iu,200) ckey, gav
  200 format('gcheck: ',a,'   globav=',f14.6)

      return
      end

c----------------------------------------------------------------------

      subroutine setinterp (along, alatg, nlong, nlatg,
     *                      alond, alatd, nx, ny, radius,
     *                      indl, weil, indb, weib)

c        Calculate indices and weights to interpolate from the agcm 
c        grid (nlong,nlatg) to the  ice grid (nx,ny). 
c        Returns [indl,weil] from the ice grid into the 
c        agcm longitude grid, and [indb,weib] from the ice grid into 
c        the agcm latitude grid.

      dimension
     *  along(nlong),  alatg(nlatg),
     *  alond(nx,ny),  alatd(nx,ny),
     *  indl(nx,ny),   weil(nx,ny),
     *  indb(nx,ny),   weib(nx,ny)

      parameter (pi=3.14159265358979, tpi=(2.*pi))

      zlong  = along(1) - 0.5*(tpi/nlong)
      zlong2 = zlong + tpi

c        Bilinear interp to model polar stereographic grid

      do j=1,ny
        do i=1,nx
          zlat = alatd(i,j)*pi/180. 
          zlon = alond(i,j)*pi/180.
          zlon = mod (zlon + 2.*pi, 2.*pi)
          if (zlon.gt.pi) zlon = zlon - 2.*pi

          val = zlon
          if (val.lt.zlong ) val = val + tpi*int(1+(zlong -val)/tpi)
          if (val.gt.zlong2) val = val - tpi*int(1+(val-zlong2)/tpi)

          if (val.le.along(1)) then
            indl(i,j) = nlong
            weil(i,j) = (along(1)-val) / (tpi/nlong)
          else if (val.ge.along(nlong)) then
            indl(i,j) = nlong
            weil(i,j) = 1. - (val-along(nlong)) / (tpi/nlong)
          else
            do 22 io = 2,nlong
              if (val.lt.along(io)) then
                indl(i,j) = io-1
                weil(i,j) = (along(io)-val) / (tpi/nlong)
                goto 24
              endif
   22       continue
   24       continue
          endif

          val = zlat
          if (val.le.alatg(1)) then
            indb(i,j) = 1
            weib(i,j) = 1.
          else if (val.ge.alatg(nlatg)) then
            indb(i,j) = nlatg
            weib(i,j) = 1.
          else
            do 32 jo = 2,nlatg
              if (val.lt.alatg(jo)) then
                indb(i,j) = jo-1
                weib(i,j) =(alatg(jo)-val) / (alatg(jo)-alatg(jo-1))
                goto 34
              endif
   32       continue
   34       continue
          endif

        enddo
      enddo

      return
      end

c----------------------------------------------------------------------

      subroutine surfice_pdd
     *      ( dt,
     *        ta,      raa,     sna,
     *        dmelta,  hsnowa,  
     *        tice,    tsno,    pdd,
     *        npoi)
 
c        Simple one-level slab "snow/ice" model 
 
      use comicephys
      use comicegrid
 
      dimension
     *  ta(nvec),      raa(nvec),    sna(nvec),
     *  dmelta(nvec),  hsnowa(nvec), 
     *  tice(nvec),    tsno(nvec),   pdd(nvec)

      dimension qdd(nvec)

      parameter (rhosno = 250.)     ! snow density, kg/m3

      logical surf3, surf4
      parameter (surf3=.true.)      ! degree day 
      parameter (surf4=.false.)     ! degree day,  parameterized diurnal
c     parameter (surf3=.false.)     ! degree day 
c     parameter (surf4=.true.)      ! degree day,  parameterized diurnal
 
c=================
      do ip=1,npoi
c=================

        zs = max (0., min (1., hsnowa(ip)/.15))  !fractional snow area

c----------------------
        if (surf3) then
c----------------------
c         pdd(ip) = max (ta(ip)-(tmelt+5.), 0.) * (dt/86400.)
c         zfac    = 3.0*(zs*1.0  + (1.-zs)*1.5)

          pdd(ip) = max (ta(ip)-tmelt, 0.) * (dt/86400.)
          zfac    = zs*3.5  + (1.-zs)*8.16                 !Ritz,CD,1997

          dmelta(ip) = zfac*pdd(ip) / dt

c---------------------------
        else if (surf4) then
c---------------------------
c         use mean ta for degree-day:
          call degree_day (dt, ta(ip), pdd(ip), qdd(ip), tmelt, 1)

          zpr = raa(ip) + sna(ip)
          raa(ip) = (1.-qdd(ip)) * zpr
          sna(ip) =     qdd(ip)  * zpr

c         zfac = zs*2.0  + (1.-zs)*3.0
c         zfac = zs*3.5  + (1.-zs)*7.0
          zfac = zs*3.0  + (1.-zs)*8.0
c         zfac = zs*4.5  + (1.-zs)*9.0
c         zfac = zs*10.  + (1.-zs)*20.
          dmelta(ip) = zfac*pdd(ip) / dt

c------------
        endif
c------------

        tice(ip) = min (ta(ip), tmelt)    ! needed for therm

c          Increment snow thickness
 
        hsnowa(ip) = hsnowa(ip) + sna(ip)*dt/rhosno
        if (hsnowa(ip).gt.0.) hsnowa(ip) = hsnowa(ip) 
c    *                        + (raa(ip) - dmelta(ip))*dt/rhosno
     *                        + (         -dmelta(ip))*dt/rhosno
        hsnowa(ip) = max (hsnowa(ip), 0.)
        tsno(ip) = tice(ip)

c==========
      enddo 
c==========
 
      return
      end

c----------------------------------------------------------------------

      subroutine degree_day (dt, ta, pdd, qdd, t0, np)

c        Degree-day parameterization, for np points, involving  
c        error function for normally-distributed diurnal/synoptic 
c        variability. Degree-day increments returned in pdd,
c        and snowfall/precip ratio in qdd.
c        t0 is zero-pdd temperature (deg K) (supplied).

      use comicephys
      use comicegrid

      dimension ta(np), pdd(np), qdd(np)

      parameter (nerf=3000, xerf=3., derf = xerf/nerf)
      dimension erf(0:nerf)
      save erf, sdt2, sdp2, pisq
c     parameter (sdt=5.5, sdp=4.5)
      parameter (sdt=5.0, sdp=5.0)
c     parameter (sdt=4.0, sdp=4.0)

      logical first
      data first /.true./
      save first

      if (first) then
        erf (0) = 0.
        do i=1,nerf
          if (i.eq.1) then
            zx  = 0.25*derf
            zdx = 0.5 *derf
          else
            zx  = (i-1)*derf
            zdx = derf
          endif
          erf(i)  = erf(i-1)  +   exp(-zx*zx)*zdx
        enddo
        sdt2 = sdt*sqrt(2.)
        sdp2 = sdp*sqrt(2.)
        pisq = sqrt(pi)
        first = .false.
      endif

      do ip=1,np

c       positive degree days:
        ztm = ta(ip) - t0
        zx = abs(ztm/sdt2)
        ierf = max (1, min (nerf, nint(zx/derf + 0.5) ))
        zpdd = 0.5*(sdt2/pisq) * exp(-(ztm/sdt2)**2)
     *       + (ztm/pisq) * (0.5*pisq + sign(1.,ztm)*erf(ierf))
        if (zpdd.lt..001) zpdd = 0.      !protect against roundoff error
        pdd(ip) = zpdd*(dt/86400.)

c       snowfall:precip ratio (use tmelt for cutoff value):
        ztp = ta(ip) - tmelt
        zx = abs(ztp/sdp2)
        ierf = max (1, min (nerf, nint(zx/derf + 0.5) ))
        zaop = (1./pisq) * (0.5*pisq - sign(1.,ztp)*erf(ierf))
        if (zaop.lt..001) zaop = 0.      !protect against roundoff error
        if (zaop.gt..999) zaop = 1.      !protect against roundoff error
        qdd(ip) = zaop

      enddo

      return
      end

c-----------------------------------------------------------------------

      subroutine domatrix (arr,arrm, facice,facorb,facco2, nmonin,itype)

c       Does "matrix method" interpolation of a meteorological driving
c       field. 
c       Computes:
c         sigma[weimat(m)*arrm(..,..,m)]   for topog,temp.
c         sigma[weimat(m)*arrm(..,..,m)]   for precip.
c         where weimat(m) are matrix weights depending on facice,facorb,
c               facco2,and the corresp values of the nmat experiments.
c       All arguments supplied unless noted.
c         arr  = interpolated field (returned, dim: lon,lat,nmonin)
c         arrm = matrix of experiment fields (dim:lon,lat,nmonin,nmat)
c         facice = weighting factor for ice (computed in fac_matrix)
c                  (0 to 1)
c         facorb = weighting factor for orbit (" " " " " " " " " " )
c                  (summer half-yr insol at alorb (fac_matrix), W/m2)
c         facco2 = weighting factor for co2   (" " " " " " " " " " )
c         itype  = 1 for topog  (additive), 
c                  2 for temp   (additive),
c                  3 for precip (additive (not ratio?)).

      use comicephys
      use comicegrid

      dimension
     *  arr(nlong,nlatg,nmonin), arrm(nlong,nlatg,nmonin,nmat)

      dimension exporb(3), expice(3)
      save exporb, expice

      data exporb             ! facorb values, half-yr summer
     *  /339.0, 360.1, 380.6/ ! insol (70S) from fluxco/me/wa below
c     from solin, plot.in.ant on pangea:
c    *  /331.0, 355.7, 378.3/ ! insol (70S) in old co,me,wa GCM expts
c    *  /380.0, 395.0, 420.0/ ! insol (55N) in 0k,11k,21k GCM expts.

      data expice           ! facice values, representing icesheet
c    *  /0.,   .25,    1./  ! extents in 0k,11k,21k GCM expts.
c     from mask, plot.in.ant on pangea:
     *  /0.,  .528,    1./  ! area/max area in co,me,wa GCM expts

      dimension weiice(3), weiorb(3), weico2(2), weimat(nmat)
 
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
c     Prescribed matrix conditions:
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
c     For topog and temp, no facice variation (no albedo fdbk):
c     Don't need two separate topogs for temp and precip since
c     elevation correction (zdelev, above) only affects temp.
c     if (itype.eq.1 .or. itype.eq.2) then
c       facice = 0.                               ! no ice   ! 777
c       facorb = exporb(1)                        ! cold orb ! 777
c     endif
c
c     For all itypes (topog, temp and precip), no facco2 variation: 
c     facco2 = 1.                                    ! 2xCO2 ! 777
c     facco2 = 0.                                    ! 3xCO2 ! 777
c     facco2 = (log(3.)-log(4.)) / (log(3.)-log(2.)) ! 4xCO2 ! 777
c
c     For all itypes (topog, temp and precip), no facorb variation: 
c     facorb = exporb(1)                          ! cold orb ! 777
c     facorb = exporb(2)                          ! med  orb ! 777
c     facorb = exporb(3)                          ! warm orb ! 777
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

c     constrain weiice's to be <= 1:
      weiice(1) = min( 1., max (0.,
     *                 (expice(2)-facice)/(expice(2)-expice(1)) ))
      weiice(3) = min (1., max (0.,
     *                  (facice-expice(2))/(expice(3)-expice(2)) ))
      weiice(2) = 1. - (weiice(1)+weiice(3))         !weiice's sum to 1

c     allow weiorb's to be > 1:
      weiorb(1) = max (0., (exporb(2)-facorb)/(exporb(2)-exporb(1)))
      weiorb(3) = max (0., (facorb-exporb(2))/(exporb(3)-exporb(2)))
      weiorb(2) = 1. - (weiorb(1)+weiorb(3))        ! weiorb's sum to 1

c     reset facorb for output (must be last call this timestep)
      if (itype.eq.3) then
        if (facorb.gt.exporb(2)) then
          facorb = weiorb(3)
        else
          facorb = -weiorb(1)
        endif
      endif

      weico2(1) = facco2
      weico2(2) = 1. - facco2

c     nb: orb is "rows", ice is "columns" (see cpath() in climate_gcm)
c Either (9x2 matrix):
      zw = 0.
      do k=1,2
        do j=1,3
          do i=1,3
            m = i + (j-1)*3 + (k-1)*9
            weimat(m) = weiorb(i)*weiice(j)*weico2(k)
            zw = zw + weimat(m)
          enddo
        enddo
      enddo
      if (abs(zw-1.).gt.1.e-6) then                  !weimat's sum to 1
        write (ioterm,'(a,e15.6)') '*** Error (domatrix):zw.ne.1,= ',zw
        stop
      endif
 
c Or (mis31 gcm):
c     z1070ma = 450.37   ! Jan insol, 80S, 1.070 Ma (W/m2)
c     z1082ma = 585.28   ! Jan insol, 80S, 1.082 Ma (W/m2)
c     weimat(1) = (z1082ma - facorb) / (z1082ma - z1070ma) 
c     weimat(1) = max (0., min (1., weimat(1)))
c     weimat(2) = 1. - weimat(1) 

      do imon=1,nmonin
        do j=1,nlatg
          do i=1,nlong
            arr(i,j,imon) = 0.
            do m=1,nmat
              arr(i,j,imon) = arr(i,j,imon) + weimat(m)*arrm(i,j,imon,m)
            enddo
c           precip:
            if (itype.eq.3) arr(i,j,imon) = max (arr(i,j,imon), 0.)
          enddo
        enddo
      enddo

      return
      end

c-----------------------------------------------------------------------

      subroutine fac_matrix (time, weirun, rco2, ecc, obl, prec, 
     *                       facice, facorb, facco2,
     *                       h, darea, nx, ny)

c        Computes weights facice, facorb, facco2 for matrix method.
c
c        time = current time, -yr BP (eg, -21000) (supplied)
c        facice = ice extent interpolation matrix factor (0-1,returned)
c        facorb = orbit interpolation matrix factor (W/m2, returned)
c        facco2 = co2 interpolation matrix factor (returned)
c        h     = ice sheet thickness, m (supplied)
c        darea = ice grid box area, m**2 (supplied)
c        nx,ny = ice grid dimensions (supplied)

      dimension h(nx,ny), darea(nx,ny)

c     for orbit:
      parameter (pi=3.14159265358979)
      parameter (alorb = -70.*pi/180.)

      save fluxco, fluxme, fluxwa

      logical first
      data first /.true./
      save first

c         Compute reference summer-half-year insolation values
c         (not currently used, hard coded in data statament 

      if (first) then
        call insolhalf (0, alorb, fluxco,
     *                  .05, 22.5*pi/180., 270.*pi/180., 0)
        call insolhalf (0, alorb, fluxme,
     *                  .0 , 23.5*pi/180.,   0.*pi/180., 0)
        call insolhalf (0, alorb, fluxwa,
     *                  .05, 24.5*pi/180.,  90.*pi/180., 0)
        write (6,*) 'fluxco=',fluxco
        write (6,*) 'fluxme=',fluxme
        write (6,*) 'fluxwa=',fluxwa

        first = .false.
      endif

c        Compute facorb, current summer-half-year insolation at alorb
      
      call insolhalf (nint(time), alorb, zflux, ecc, obl, prec, 0)
      facorb = zflux
      write (196,'(/i10,4(a,f12.5))') nint(time), 'ecc=',ecc,
     *  '  obl=',obl*180./pi, '  prec=',prec*180./pi,'  zflux=',zflux
      call flush(196)

c        Compute facice, current ice-sheet surface area 
c        (albedo/topog feedbck)

      ztotari = 0.
      ztotice = 0.
      do j=1,ny
        do i=1,nx
          if (h(i,j).gt.0.001) ztotari = ztotari + darea(i,j)
          ztotice = ztotice + h(i,j)*darea(i,j)
        enddo
      enddo
      ztotari = ztotari*1.e-6 ! m2 to km2
      ztotice = ztotice*1.e-9 ! m3 to km3
      facice = min (1., (ztotari/13.e6))  ! 777
c     facice = min (1., (ztotice/28.e6))  ! 777

c        Compute facco2 (radiative effect of co2 is logarithmic
c        wrt concentration):

      facco2 = (log(3.)-log(rco2)) / (log(3.)-log(2.))

c     write (6,'(a, i10, 3f8.3, i10, f8.3)') 
c    *  'time dflux facorb facco2 totice facice: ',
c    *  nint(time), zflux, facorb, facco2, nint(ztotice), facice

      return
      end

c-----------------------------------------------------------------------

c****
#else
c****

      subroutine climate_gcm ()
      return
      end

c*****
#endif
c*****
